package pit;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.jms.*;
import javax.naming.*;

/*
 * This is the ONLY file that you are to edit.  It is the model of play for
 * every PITplayer.  Each PITplayer instantiates this model and uses it to
 * process the messages it receives.
 */
public class PITPlayerModel {
    // Each PITplayer has a unique myPlayerNumber.  It is set in the PITPlayer constructor.

    private int myPlayerNumber;
    // Cards is this player's set of cards.  
    private final ArrayList cards = new ArrayList();
    // tradeCount counts trades.
    private int tradeCount = 0;
    // maxTrades is the maximum number of trades, after which trading is stopped.
    private final int maxTrades = 3500;
    // numPlayers are the number of Players trading.  This comes with a NewHand from the PITinit servlet
    private int numPlayers = 0;
    // The snapshot servlet (PITsnapshot) is expecting to be passed an ObjectMessage
    // where the object is a HashMap. Therefore this definition of that HashMap is 
    // provided although it is not currently used (it is for you to use).
    // Also included below is a utility method that will turn a HashMap into a string
    // which is useful for printing diagnostic messages to the console.
    // Before sending state to the PITsnapshot queue, add the myPlayerNumber to
    // the HashMap.  This will identify who the snapshot is coming from.
    // I.e. state.put("Player", myPlayerNumber);
    private HashMap<String, Integer> state;
    
    // This set is used to record all other players' number so that can help use identify the
    // source.
    private Set<Integer> others;
    // This Map is used to collect all input channels that might be listened to. We can change
    // the state of each channe.
    private Map<Integer, Channel> channels;
    // This boolean is used for identify wheterher this is the first time this player receive
    // the marker or not.
    private boolean firstMarker = true;

    // PITPlayerModel constructor saves what number player this object represents.
    PITPlayerModel(int myNumber) {
        myPlayerNumber = myNumber;
        others = new HashSet<Integer>(4);
        others.add(0);
        others.add(1);
        others.add(2);
        others.add(3);
        others.remove(myNumber);
        channels = new HashMap<Integer, Channel>();
        for (int i : others) {
            channels.put(i, new Channel(i));
        }
        state = new HashMap<String, Integer>();
    }

    public void onMessage(Message message) {
        try {
            if (message instanceof ObjectMessage) {
                Object o = ((ObjectMessage) message).getObject();

                // There are 4 types of messages:  Reset, NewHand, Trade, and Marker

                // Reset the Player.  The Reset message is generated by the PITinit servlet
                if (o instanceof Reset) {
                    System.out.println("PITplayer" + myPlayerNumber + " received reset");
                    // Drop all cards in hand
                    cards.clear();
                    tradeCount = 0;
                    numPlayers = 0;
                    // Reply to the PITinit servlet acknowledging the Reset
                    sendToQueue("jms/PITmonitor", (Reset) o);
                    return;

                    // NewHand received from PITinit
                } else if (o instanceof NewHand) {
                    // Add new hand cards.  
                    // It is actually possible that a trade had added a card already.
                    cards.addAll(((NewHand) o).handCard);
                    numPlayers = ((NewHand) o).numPlayers;
                    System.out.println("PITplayer" + myPlayerNumber + " new hand: " + toString(cards));

                    // Receive a Trade from another Player
                } else if (o instanceof Trade) {
                    // Having received a Trade card from another Player, add it to my hand of cards
                    Trade trade = (Trade) o;
                    cards.add(trade.tradeCard);
                    int num = trade.sourcePlayer;
                    if (others.contains(num)) {
                        Channel c = channels.get(num);
                        if (!c.isEmpty && c.startListen) {
                            // If this is a available channel this
                            // player is listening, we record this
                            // card information into the channel's
                            // arraylist which is recording the resource
                            // via this channel.
                            c.getCards().add(trade.tradeCard);
                        }
                    }
                    System.out.println("PITplayer" + myPlayerNumber + " received: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
                    System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
                
                } else if (o instanceof Marker) {
                    System.out.println("Here is Marker");
                    int source = ((Marker) o).source;
                    if (firstMarker) {
                        // Count the cards in the player's hand.
                        countInHand(this.cards);
                        // Do send markers to all other players.
                        sendMarkers();
                        // Set the firstMarker flag to false so that
                        // next time this player receive a mareker,
                        // it will jump to not-first-one conditoin.
                        firstMarker = false;
                        
                        // Mark the marker in channel to empty so that
                        // this player will not listen to this channel.
                        if (source != -1) {
                            Channel c = channels.get(source);
                            c.isEmpty = true;
                        }
                        // Start listening all channels except the channel
                        // the player receive the marker.
                        startListenChannel();
                    } else {
                        //Not-First-One condition.
                            
                            Channel c = channels.get(source);
                            // Count the cards this player receive via 
                            // this channel since this
                            // player start listening to this channel.
                            countInHand(c.getCards());
                            c.isEmpty = true;
                            if (allChannelEmpty()) {
                                // If all input channel are marked as
                                // empty, this player can send this state
                                // to the snapshot recevier and reset itself.
                                state.put("Player", myPlayerNumber);
                                sendStateAndReset();
                            }
                        
                    }
                }
            }

            // if hit maxTrades limit, then stop sending trades
            if (maxTrades(maxTrades)) {
                return;
            }

            /*
             * If numPlayers == 0, while we have received a Trade, we have not 
             * received our NewHand yet, so we don't know how many players there 
             * are.  Therefore, don't send out a Trade at this time.
             * 
             */
            if (numPlayers == 0) {
                return;
            }

            // Create a new Trade from my set of cards, and send to another player
            if (cards.size() > 0) {
                Trade newTrade = new Trade();
                newTrade.sourcePlayer = myPlayerNumber;
                newTrade.tradeCard = (String) cards.remove(0);

                // Find a random player to trade to (not including myself)
                int sendTo = myPlayerNumber;
                while (sendTo == myPlayerNumber) {
                    sendTo = Math.round((float) Math.random() * (numPlayers - 1));
                }
                //Send the card to the other player
                System.out.println("PITplayer" + myPlayerNumber + " sending: " + newTrade.tradeCard + " to player: " + sendTo);
                String sendToJNDI = "jms/PITplayer" + sendTo;
                sendToQueue(sendToJNDI, newTrade);
            }
        } catch (JMSException e) {
            System.out.println("JMS Exception thrown" + e);
        } catch (Exception ex) {
            ex.printStackTrace();
            Logger.getLogger(PITPlayerModel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * This method will send this player's state to 
     * the snapshot receiver and reset itself.
     * @throws Exception 
     */
    private void sendStateAndReset() throws Exception {

        String sendToJNDI = "jms/PITsnapshot";
        // Send snapshot.
        sendToQueue(sendToJNDI, state);
        // Reset firstMarker flag.
        firstMarker = true;
        // Clear this stae.
        state.clear();
        // Reset all input channels.
        for (int i : others) {
            Channel c = channels.get(i);
            c.isEmpty = false;
            c.startListen = false;
            c.getCards().clear();
        }
    }

    /**
     * This method will make all not empty channels' states to 
     * start recording,.
     */
    private void startListenChannel() {
        for (int i : others) {
            Channel c = channels.get(i);
            if (!c.isEmpty && firstMarker == false) {
                c.startListen = true;
            }
        }
    }

    /**
     * This method will count the input cards and record
     * the result into the state.
     * @param cards 
     */
    private void countInHand(ArrayList cards) {
        for (Object o : cards) {
            String card = (String) o;
            //If this resource allready exists,
            //increase the number of resources by 1.
            if (state.containsKey(card)) {
                int x = state.get(card);
                x++;
                state.put(card, x);
            } else {
                // If the resource didn't appeared in the state,
                // put it into the state with initial number 1.
                state.put(card, 1);
            }
        }
    }

    /**
     * This will send markers to all other players from this
     * player.
     * @throws Exception 
     */
    private void sendMarkers() throws Exception {
        for (int i : others) {
            String sendToJNDI = "jms/PITplayer" + i;
            Marker m = new Marker(myPlayerNumber);
            sendToQueue(sendToJNDI, m);
        }
    }

    /**
     * This will check all channels are empty or not. It
     * iterate all channels this player has and check whether it
     * is empty or not.
     * @return 
     */
    private boolean allChannelEmpty() {
        for (int i : others) {
            Channel c = channels.get(i);
            if (!c.isEmpty) {
                return false;
            }
        }
        return true;
    }

    // Create a string of hand size and all cards for use in printing
    private String toString(ArrayList hand) {

        String cardsString = "size: " + hand.size() + " ";
        for (int i = 0; i < hand.size(); i++) {
            cardsString += hand.get(i) + " ";
        }
        return cardsString;
    }

    // Create a printable version of the "state".
    private String toString(HashMap<String, Integer> state) {
        String stateString = "";
        for (Iterator it = state.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry) it.next();
            String commodity = (String) entry.getKey();
            int number = ((Integer) entry.getValue()).intValue();
            stateString += "{" + commodity + ":" + number + "} ";
        }
        return stateString;
    }

    // Send an object to a Queue, given its JNDI name
    private void sendToQueue(String queueJNDI, Serializable message) throws Exception {
        // Gather necessary JMS resources
        Context ctx = new InitialContext();
        Connection con = ((ConnectionFactory) ctx.lookup("jms/myConnectionFactory")).createConnection();
        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue q = (Queue) ctx.lookup(queueJNDI);
        MessageProducer writer = session.createProducer(q);
        ObjectMessage msg = session.createObjectMessage(message);
        // Send the object to the Queue
        writer.send(msg);
        session.close();
        con.close();
        ctx.close();
    }

    // stop trading when hit maxTrades
    private boolean maxTrades(int max) {
        // stop trading after some number of trades
        if ((tradeCount % 100) == 0) {
            System.out.println("PITplayer" + myPlayerNumber + " tradeCount: " + tradeCount);
        }
        return (tradeCount++ < max) ? false : true;
    }

    /**
     * This class is used for encapsulate channels information:
     * startListen - this channel are being listened or not;
     * isEmpty - this channel has been marked empty by player or not;
     * sourceNumber - the player number that send message to this player via this channel;
     * cardsInChannel - container for recording all cards received by this channel.
     */
    private class Channel {

        boolean startListen = false;
        boolean isEmpty = false;
        int sourceNumber = 0;
        ArrayList cardsInChannel = new ArrayList<String>();

        Channel(int num) {
            sourceNumber = num;
        }

        public void add(String card) {
            cardsInChannel.add(card);
        }

        public ArrayList getCards() {
            return cardsInChannel;
        }
    }
}
